-- AI Model Registry Lineage Tables
-- Migration: 003_add_lineage_tables
-- Description: Create tables for tracking model lineage and metadata relationships

-- Create enum for lineage node types
CREATE TYPE lineage_node_type AS ENUM ('dataset', 'model', 'training_run', 'commit', 'artifact');

-- Create enum for lineage relationship types
CREATE TYPE lineage_relationship AS ENUM ('derived_from', 'trained_on', 'based_on', 'generated_by', 'contains');

-- Lineage nodes table
CREATE TABLE lineage_nodes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  type lineage_node_type NOT NULL,
  name VARCHAR(255) NOT NULL,
  version VARCHAR(50),
  uri TEXT,
  metadata JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  
  -- Constraints
  CONSTRAINT lineage_nodes_name_check CHECK (length(name) > 0),
  
  -- Unique constraint on type, name, and version combination
  UNIQUE(type, name, version)
);

-- Lineage edges table (relationships between nodes)
CREATE TABLE lineage_edges (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  source_id UUID NOT NULL REFERENCES lineage_nodes(id) ON DELETE CASCADE,
  target_id UUID NOT NULL REFERENCES lineage_nodes(id) ON DELETE CASCADE,
  relationship lineage_relationship NOT NULL,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  
  -- Constraints
  CONSTRAINT lineage_edges_no_self_reference CHECK (source_id != target_id),
  
  -- Unique constraint to prevent duplicate relationships
  UNIQUE(source_id, target_id, relationship)
);

-- Indexes for lineage tables

-- Lineage nodes indexes
CREATE INDEX idx_lineage_nodes_type ON lineage_nodes(type);
CREATE INDEX idx_lineage_nodes_name ON lineage_nodes(name);
CREATE INDEX idx_lineage_nodes_version ON lineage_nodes(version);
CREATE INDEX idx_lineage_nodes_metadata ON lineage_nodes USING GIN(metadata);
CREATE INDEX idx_lineage_nodes_created_at ON lineage_nodes(created_at);

-- Lineage edges indexes
CREATE INDEX idx_lineage_edges_source_id ON lineage_edges(source_id);
CREATE INDEX idx_lineage_edges_target_id ON lineage_edges(target_id);
CREATE INDEX idx_lineage_edges_relationship ON lineage_edges(relationship);
CREATE INDEX idx_lineage_edges_created_at ON lineage_edges(created_at);

-- Composite indexes for common queries
CREATE INDEX idx_lineage_nodes_type_name ON lineage_nodes(type, name);
CREATE INDEX idx_lineage_edges_source_relationship ON lineage_edges(source_id, relationship);
CREATE INDEX idx_lineage_edges_target_relationship ON lineage_edges(target_id, relationship);

-- Apply audit triggers to lineage tables
CREATE TRIGGER audit_lineage_nodes_trigger
  AFTER INSERT OR UPDATE OR DELETE ON lineage_nodes
  FOR EACH ROW EXECUTE FUNCTION audit_log_trigger();

CREATE TRIGGER audit_lineage_edges_trigger
  AFTER INSERT OR UPDATE OR DELETE ON lineage_edges
  FOR EACH ROW EXECUTE FUNCTION audit_log_trigger();

-- Function to validate lineage relationships
CREATE OR REPLACE FUNCTION validate_lineage_relationship()
RETURNS TRIGGER AS $
DECLARE
  source_type lineage_node_type;
  target_type lineage_node_type;
BEGIN
  -- Get source and target node types
  SELECT type INTO source_type FROM lineage_nodes WHERE id = NEW.source_id;
  SELECT type INTO target_type FROM lineage_nodes WHERE id = NEW.target_id;
  
  -- Validate relationship based on node types
  CASE NEW.relationship
    WHEN 'trained_on' THEN
      -- Models can be trained on datasets
      IF NOT (target_type = 'model' AND source_type = 'dataset') THEN
        RAISE EXCEPTION 'Invalid trained_on relationship: % -> %', source_type, target_type;
      END IF;
    
    WHEN 'derived_from' THEN
      -- Models can be derived from commits, other models, or artifacts
      IF NOT (target_type = 'model' AND source_type IN ('commit', 'model', 'artifact')) THEN
        RAISE EXCEPTION 'Invalid derived_from relationship: % -> %', source_type, target_type;
      END IF;
    
    WHEN 'based_on' THEN
      -- Models can be based on other models
      IF NOT (target_type = 'model' AND source_type = 'model') THEN
        RAISE EXCEPTION 'Invalid based_on relationship: % -> %', source_type, target_type;
      END IF;
    
    WHEN 'generated_by' THEN
      -- Models can be generated by training runs
      IF NOT (target_type = 'model' AND source_type = 'training_run') THEN
        RAISE EXCEPTION 'Invalid generated_by relationship: % -> %', source_type, target_type;
      END IF;
    
    WHEN 'contains' THEN
      -- Models can contain artifacts
      IF NOT (source_type = 'model' AND target_type = 'artifact') THEN
        RAISE EXCEPTION 'Invalid contains relationship: % -> %', source_type, target_type;
      END IF;
    
    ELSE
      RAISE EXCEPTION 'Unknown relationship type: %', NEW.relationship;
  END CASE;
  
  RETURN NEW;
END;
$ language 'plpgsql';

-- Apply relationship validation trigger
CREATE TRIGGER validate_lineage_relationship_trigger
  BEFORE INSERT OR UPDATE ON lineage_edges
  FOR EACH ROW EXECUTE FUNCTION validate_lineage_relationship();

-- Function to prevent circular dependencies in lineage
CREATE OR REPLACE FUNCTION prevent_lineage_cycles()
RETURNS TRIGGER AS $
BEGIN
  -- Check if adding this edge would create a cycle
  IF EXISTS (
    WITH RECURSIVE lineage_path AS (
      -- Start from the new target
      SELECT NEW.target_id as node_id, 1 as depth
      
      UNION ALL
      
      -- Follow outgoing edges
      SELECT e.target_id, lp.depth + 1
      FROM lineage_edges e
      JOIN lineage_path lp ON e.source_id = lp.node_id
      WHERE lp.depth < 10 -- Prevent infinite recursion
    )
    SELECT 1 FROM lineage_path WHERE node_id = NEW.source_id
  ) THEN
    RAISE EXCEPTION 'Adding this relationship would create a circular dependency';
  END IF;
  
  RETURN NEW;
END;
$ language 'plpgsql';

-- Apply cycle prevention trigger
CREATE TRIGGER prevent_lineage_cycles_trigger
  BEFORE INSERT OR UPDATE ON lineage_edges
  FOR EACH ROW EXECUTE FUNCTION prevent_lineage_cycles();

-- View for easy lineage querying
CREATE VIEW lineage_graph AS
SELECT 
  e.id as edge_id,
  e.relationship,
  e.metadata as edge_metadata,
  e.created_at as edge_created_at,
  sn.id as source_id,
  sn.type as source_type,
  sn.name as source_name,
  sn.version as source_version,
  sn.uri as source_uri,
  sn.metadata as source_metadata,
  tn.id as target_id,
  tn.type as target_type,
  tn.name as target_name,
  tn.version as target_version,
  tn.uri as target_uri,
  tn.metadata as target_metadata
FROM lineage_edges e
JOIN lineage_nodes sn ON e.source_id = sn.id
JOIN lineage_nodes tn ON e.target_id = tn.id;

-- Function to get lineage for a specific node
CREATE OR REPLACE FUNCTION get_node_lineage(
  node_id UUID,
  max_depth INTEGER DEFAULT 5,
  direction TEXT DEFAULT 'both' -- 'upstream', 'downstream', or 'both'
)
RETURNS TABLE(
  node_id UUID,
  node_type lineage_node_type,
  node_name VARCHAR(255),
  node_version VARCHAR(50),
  node_uri TEXT,
  node_metadata JSONB,
  depth INTEGER,
  path UUID[]
) AS $
BEGIN
  RETURN QUERY
  WITH RECURSIVE lineage_traversal AS (
    -- Base case: start with the given node
    SELECT 
      n.id,
      n.type,
      n.name,
      n.version,
      n.uri,
      n.metadata,
      0 as depth,
      ARRAY[n.id] as path
    FROM lineage_nodes n
    WHERE n.id = node_id
    
    UNION ALL
    
    -- Recursive case: traverse connected nodes
    SELECT 
      n.id,
      n.type,
      n.name,
      n.version,
      n.uri,
      n.metadata,
      lt.depth + 1,
      lt.path || n.id
    FROM lineage_nodes n
    JOIN lineage_edges e ON (
      CASE 
        WHEN direction = 'upstream' THEN e.target_id = lt.node_id AND e.source_id = n.id
        WHEN direction = 'downstream' THEN e.source_id = lt.node_id AND e.target_id = n.id
        ELSE (e.source_id = lt.node_id AND e.target_id = n.id) OR 
             (e.target_id = lt.node_id AND e.source_id = n.id)
      END
    )
    JOIN lineage_traversal lt ON TRUE
    WHERE lt.depth < max_depth
      AND NOT (n.id = ANY(lt.path)) -- Prevent cycles
  )
  SELECT * FROM lineage_traversal
  ORDER BY depth, node_name;
END;
$ language 'plpgsql';